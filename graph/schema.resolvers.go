package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.47

import (
	"context"
	"strconv"
	"time"

	"github.com/likimiad/ozon_fintech/graph/generated"
	"github.com/likimiad/ozon_fintech/internal/database/models"
	"log/slog"
)

// ID is the resolver for the id field.
func (r *commentResolver) ID(ctx context.Context, obj *models.Comment) (string, error) {
	return strconv.FormatUint(uint64(obj.ID), 10), nil
}

// PostID is the resolver for the postId field.
func (r *commentResolver) PostID(ctx context.Context, obj *models.Comment) (string, error) {
	return strconv.FormatUint(uint64(obj.PostID), 10), nil
}

// CommentID is the resolver for the commentId field.
func (r *commentResolver) CommentID(ctx context.Context, obj *models.Comment) (*string, error) {
	if obj.CommentID == nil {
		return nil, nil
	}
	idStr := strconv.FormatUint(uint64(*obj.CommentID), 10)
	return &idStr, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *commentResolver) CreatedAt(ctx context.Context, obj *models.Comment) (string, error) {
	return obj.CreatedAt.Format(time.RFC3339), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *commentResolver) UpdatedAt(ctx context.Context, obj *models.Comment) (string, error) {
	return obj.UpdatedAt.Format(time.RFC3339), nil
}

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, title string, content string, author string, commentsEnabled bool) (*models.Post, error) {
	slog.Info("createPost called", "title", title, "author", author)

	post := &models.Post{
		Title:           title,
		Content:         content,
		Author:          author,
		CommentsEnabled: commentsEnabled,
	}
	err := r.PostService.CreatePost(post)
	if err != nil {
		slog.Error("error creating post", "error", err)
		return nil, err
	}
	return post, nil
}

// UpdatePost is the resolver for the updatePost field.
func (r *mutationResolver) UpdatePost(ctx context.Context, id string, title *string, content *string, commentsEnabled *bool) (*models.Post, error) {
	slog.Info("updatePost called", "id", id)

	postID, err := strconv.ParseUint(id, 10, 64)
	if err != nil {
		slog.Error("error parsing post ID", "id", id, "error", err)
		return nil, err
	}
	post, err := r.PostService.GetPostByID(uint(postID))
	if err != nil {
		slog.Error("error fetching post", "id", id, "error", err)
		return nil, err
	}
	if title != nil {
		post.Title = *title
	}
	if content != nil {
		post.Content = *content
	}
	if commentsEnabled != nil {
		post.CommentsEnabled = *commentsEnabled
	}
	err = r.PostService.UpdatePost(post)
	if err != nil {
		slog.Error("error updating post", "id", id, "error", err)
		return nil, err
	}
	return post, nil
}

// DeletePost is the resolver for the deletePost field.
func (r *mutationResolver) DeletePost(ctx context.Context, id string) (*bool, error) {
	slog.Info("deletePost called", "id", id)

	postID, err := strconv.ParseUint(id, 10, 64)
	if err != nil {
		slog.Error("error parsing post ID", "id", id, "error", err)
		return nil, err
	}
	err = r.PostService.DeletePost(uint(postID))
	if err != nil {
		slog.Error("error deleting post", "id", id, "error", err)
		return nil, err
	}
	success := true
	return &success, nil
}

// CreateComment is the resolver for the createComment field.
func (r *mutationResolver) CreateComment(ctx context.Context, postID string, commentID *string, author string, content string) (*models.Comment, error) {
	slog.Info("createComment called", "postID", postID, "author", author)

	postIDUint, err := strconv.ParseUint(postID, 10, 64)
	if err != nil {
		slog.Error("error parsing post ID", "postID", postID, "error", err)
		return nil, err
	}
	var parentID *uint
	if commentID != nil {
		id, err := strconv.ParseUint(*commentID, 10, 64)
		if err != nil {
			slog.Error("error parsing comment ID", "commentID", *commentID, "error", err)
			return nil, err
		}
		tmp := uint(id)
		parentID = &tmp
	}
	comment, err := r.PostService.CreateComment(uint(postIDUint), parentID, author, content)
	if err != nil {
		slog.Error("error creating comment", "error", err)
		return nil, err
	}
	// Notify subscribers about the new comment
	r.mu.Lock()
	if ch, ok := r.subscriptions[uint(postIDUint)]; ok {
		ch <- comment
	}
	r.mu.Unlock()
	return comment, nil
}

// UpdateComment is the resolver for the updateComment field.
func (r *mutationResolver) UpdateComment(ctx context.Context, id string, content string) (*models.Comment, error) {
	slog.Info("updateComment called", "id", id)

	commentID, err := strconv.ParseUint(id, 10, 64)
	if err != nil {
		slog.Error("error parsing comment ID", "id", id, "error", err)
		return nil, err
	}
	comment, err := r.PostService.UpdateComment(uint(commentID), content)
	if err != nil {
		slog.Error("error updating comment", "id", id, "error", err)
		return nil, err
	}
	return comment, nil
}

// DeleteComment is the resolver for the deleteComment field.
func (r *mutationResolver) DeleteComment(ctx context.Context, id string) (*bool, error) {
	slog.Info("deleteComment called", "id", id)

	commentID, err := strconv.ParseUint(id, 10, 64)
	if err != nil {
		slog.Error("error parsing comment ID", "id", id, "error", err)
		return nil, err
	}
	err = r.PostService.DeleteComment(uint(commentID))
	if err != nil {
		slog.Error("error deleting comment", "id", id, "error", err)
		return nil, err
	}
	success := true
	return &success, nil
}

// ID is the resolver for the id field.
func (r *postResolver) ID(ctx context.Context, obj *models.Post) (string, error) {
	return strconv.FormatUint(uint64(obj.ID), 10), nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *postResolver) CreatedAt(ctx context.Context, obj *models.Post) (string, error) {
	return obj.CreatedAt.Format(time.RFC3339), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *postResolver) UpdatedAt(ctx context.Context, obj *models.Post) (string, error) {
	return obj.UpdatedAt.Format(time.RFC3339), nil
}

// Posts is the resolver for the posts field.
func (r *queryResolver) Posts(ctx context.Context) ([]*models.Post, error) {
	slog.Info("posts query called")

	posts, err := r.PostService.GetPosts()
	if err != nil {
		slog.Error("error fetching posts", "error", err)
		return nil, err
	}

	// ? From []models.Post to []*models.Post
	postPtrs := make([]*models.Post, len(posts))
	for i := range posts {
		postPtrs[i] = &posts[i]
	}

	return postPtrs, nil
}

// Post is the resolver for the post field.
func (r *queryResolver) Post(ctx context.Context, id string) (*models.Post, error) {
	slog.Info("post query called", "id", id)

	postID, err := strconv.ParseUint(id, 10, 64)
	if err != nil {
		slog.Error("error parsing post ID", "id", id, "error", err)
		return nil, err
	}
	post, err := r.PostService.GetPostByID(uint(postID))
	if err != nil {
		slog.Error("error fetching post", "id", id, "error", err)
		return nil, err
	}
	return post, nil
}

// CommentAdded is the resolver for the commentAdded field.
func (r *subscriptionResolver) CommentAdded(ctx context.Context, postID string) (<-chan *models.Comment, error) {
	slog.Info("commentAdded subscription called", "postID", postID)

	postIDUint, err := strconv.ParseUint(postID, 10, 64)
	if err != nil {
		slog.Error("error parsing post ID", "postID", postID, "error", err)
		return nil, err
	}
	r.mu.Lock()
	ch := make(chan *models.Comment, 1)
	r.subscriptions[uint(postIDUint)] = ch
	r.mu.Unlock()
	return ch, nil
}

// Comment returns generated.CommentResolver implementation.
func (r *Resolver) Comment() generated.CommentResolver { return &commentResolver{r} }

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Post returns generated.PostResolver implementation.
func (r *Resolver) Post() generated.PostResolver { return &postResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// Subscription returns generated.SubscriptionResolver implementation.
func (r *Resolver) Subscription() generated.SubscriptionResolver { return &subscriptionResolver{r} }

type commentResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type postResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
